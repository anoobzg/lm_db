#include "lm/gcode/gcode_processor.h"
#include <fstream>
#include <sstream>
#include <regex>
#include <algorithm>
#include <iomanip>
#include <map>

namespace lm {
namespace gcode {

GCodeProcessor::GCodeProcessor(std::shared_ptr<crypto::AESEncryption> encryption)
    : encryption_(encryption) {
}

GCodeProcessor::GCodeProcessor(const std::string& password) {
    auto key = crypto::AESEncryption::generateKeyFromPassword(password);
    encryption_ = std::make_shared<crypto::AESEncryption>(key);
}

bool GCodeProcessor::encryptGCodeFile(const std::string& inputPath, const std::string& outputPath) {
    // 首先验证输入文件是否为有效的G-code文件
    if (!validateGCodeFile(inputPath)) {
        return false;
    }
    
    // 使用加密器加密文件
    return encryption_->encryptFile(inputPath, outputPath);
}

bool GCodeProcessor::decryptGCodeFile(const std::string& inputPath, const std::string& outputPath) {
    // 解密文件
    bool success = encryption_->decryptFile(inputPath, outputPath);
    
    if (success) {
        // 验证解密后的文件是否为有效的G-code文件
        return validateGCodeFile(outputPath);
    }
    
    return false;
}

bool GCodeProcessor::validateGCodeFile(const std::string& filePath) {
    std::ifstream file(filePath);
    if (!file.is_open()) {
        return false;
    }
    
    std::string line;
    int lineCount = 0;
    int gcodeCommandCount = 0;
    
    while (std::getline(file, line) && lineCount < 1000) { // 只检查前1000行
        lineCount++;
        
        // 去除注释和空白
        size_t commentPos = line.find(';');
        if (commentPos != std::string::npos) {
            line = line.substr(0, commentPos);
        }
        
        // 去除前后空白
        line.erase(0, line.find_first_not_of(" \t\r\n"));
        line.erase(line.find_last_not_of(" \t\r\n") + 1);
        
        if (line.empty()) {
            continue;
        }
        
        // 检查是否为G-code命令
        if (isGCodeCommand(line)) {
            gcodeCommandCount++;
        }
    }
    
    file.close();
    
    // 如果找到至少一个G-code命令，认为是有效的G-code文件
    return gcodeCommandCount > 0;
}

std::string GCodeProcessor::getGCodeFileInfo(const std::string& filePath) {
    std::ifstream file(filePath);
    if (!file.is_open()) {
        return "Error: Cannot open file";
    }
    
    std::stringstream info;
    info << "G-code File Information:\n";
    info << "======================\n";
    
    // 获取文件大小
    file.seekg(0, std::ios::end);
    size_t fileSize = file.tellg();
    file.seekg(0, std::ios::beg);
    
    info << "File size: " << fileSize << " bytes\n";
    
    // 统计行数和命令
    std::string line;
    int totalLines = 0;
    int gcodeLines = 0;
    int commentLines = 0;
    int emptyLines = 0;
    
    auto commandCounts = countGCodeCommands(filePath);
    
    while (std::getline(file, line)) {
        totalLines++;
        
        // 去除前后空白
        line.erase(0, line.find_first_not_of(" \t\r\n"));
        line.erase(line.find_last_not_of(" \t\r\n") + 1);
        
        if (line.empty()) {
            emptyLines++;
        } else if (line[0] == ';') {
            commentLines++;
        } else if (isGCodeCommand(line)) {
            gcodeLines++;
        }
    }
    
    file.close();
    
    info << "Total lines: " << totalLines << "\n";
    info << "G-code commands: " << gcodeLines << "\n";
    info << "Comment lines: " << commentLines << "\n";
    info << "Empty lines: " << emptyLines << "\n\n";
    
    info << "G-code Command Statistics:\n";
    info << "-------------------------\n";
    
    for (const auto& cmd : commandCounts) {
        info << std::setw(8) << std::left << cmd.first << ": " << cmd.second << " times\n";
    }
    
    return info.str();
}

bool GCodeProcessor::createSampleGCodeFile(const std::string& filePath) {
    std::ofstream file(filePath);
    if (!file.is_open()) {
        return false;
    }
    
    file << "; Sample G-code file for 3D printing\n";
    file << "; Generated by lm_db G-code processor\n\n";
    
    file << "; Start G-code\n";
    file << "G21 ; Set units to millimeters\n";
    file << "G90 ; Set absolute positioning\n";
    file << "M82 ; Set extruder to absolute mode\n";
    file << "M104 S200 ; Set extruder temperature\n";
    file << "M140 S60 ; Set bed temperature\n";
    file << "G28 ; Home all axes\n";
    file << "G1 Z15.0 F9000 ; Move the platform down 15mm\n";
    file << "M109 S200 ; Wait for extruder temperature\n";
    file << "M190 S60 ; Wait for bed temperature\n\n";
    
    file << "; First layer\n";
    file << "G1 X0 Y0 Z0.3 F3000 ; Move to start position\n";
    file << "G1 X10 Y0 E0.1 F1500 ; Extrude first line\n";
    file << "G1 X10 Y10 E0.2 F1500 ; Extrude second line\n";
    file << "G1 X0 Y10 E0.3 F1500 ; Extrude third line\n";
    file << "G1 X0 Y0 E0.4 F1500 ; Complete square\n\n";
    
    file << "; Second layer\n";
    file << "G1 Z0.6 F3000 ; Move up one layer\n";
    file << "G1 X0 Y0 E0.5 F1500 ; Start second layer\n";
    file << "G1 X10 Y0 E0.6 F1500\n";
    file << "G1 X10 Y10 E0.7 F1500\n";
    file << "G1 X0 Y10 E0.8 F1500\n";
    file << "G1 X0 Y0 E0.9 F1500\n\n";
    
    file << "; End G-code\n";
    file << "G1 Z15.0 F9000 ; Move platform up\n";
    file << "M104 S0 ; Turn off extruder\n";
    file << "M140 S0 ; Turn off bed\n";
    file << "G28 X0 Y0 ; Home X and Y axes\n";
    file << "M84 ; Disable steppers\n";
    
    file.close();
    return true;
}

bool GCodeProcessor::isGCodeCommand(const std::string& line) {
    // 简单的G-code命令检测
    // G-code命令通常以G、M、T等字母开头，后跟数字
    std::regex gcodePattern(R"(^[GMT]\d+)");
    return std::regex_search(line, gcodePattern);
}

std::vector<std::pair<std::string, int>> GCodeProcessor::countGCodeCommands(const std::string& filePath) {
    std::ifstream file(filePath);
    std::map<std::string, int> commandCounts;
    
    if (!file.is_open()) {
        return {};
    }
    
    std::string line;
    while (std::getline(file, line)) {
        // 去除注释和空白
        size_t commentPos = line.find(';');
        if (commentPos != std::string::npos) {
            line = line.substr(0, commentPos);
        }
        
        line.erase(0, line.find_first_not_of(" \t\r\n"));
        line.erase(line.find_last_not_of(" \t\r\n") + 1);
        
        if (line.empty()) {
            continue;
        }
        
        // 提取G-code命令
        std::regex commandPattern(R"(([GMT]\d+))");
        std::sregex_iterator iter(line.begin(), line.end(), commandPattern);
        std::sregex_iterator end;
        
        for (; iter != end; ++iter) {
            std::string command = (*iter)[1].str();
            commandCounts[command]++;
        }
    }
    
    file.close();
    
    // 转换为vector并按命令排序
    std::vector<std::pair<std::string, int>> result(commandCounts.begin(), commandCounts.end());
    std::sort(result.begin(), result.end());
    
    return result;
}

} // namespace gcode
} // namespace lm
